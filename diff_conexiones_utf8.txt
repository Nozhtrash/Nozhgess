diff --git a/Utilidades/Mezclador/Conexiones.py b/Utilidades/Mezclador/Conexiones.py
index 1489f10..b507f7d 100644
--- a/Utilidades/Mezclador/Conexiones.py
+++ b/Utilidades/Mezclador/Conexiones.py
@@ -1,27 +1,27 @@
-# Mezclador/Conexiones.py
+´╗┐# Mezclador/Conexiones.py
 # -*- coding: utf-8 -*-
 """
 ==============================================================================
                       CONEXIONES.PY - NOZHGESS v1.0
 ==============================================================================
-Archivo central del sistema - Orquesta todo el proceso de revisi├│n.
+Archivo central del sistema - Orquesta todo el proceso de revisi├â┬│n.
 
 Flujo principal:
-1. Carga la misi├│n desde Mision_Actual.py
+1. Carga la misi├â┬│n desde Mision_Actual.py
 2. Conecta al navegador Edge
 3. Lee el Excel de entrada
 4. Por cada paciente:
    - Busca en SIGGES
    - Lee mini tabla
    - Si hay match, va a cartola
-   - Analiza cada misi├│n (objetivos, habilitantes, excluyentes, etc.)
+   - Analiza cada misi├â┬│n (objetivos, habilitantes, excluyentes, etc.)
    - Guarda resultados
 5. Genera Excel final con estilos
 
 Autor: Sistema Nozhgess
 ==============================================================================
 """
-# Librer├¡a Est├índar
+# Librer├â┬¡a Est├â┬índar
 from __future__ import annotations
 import ast
 import copy
@@ -38,16 +38,16 @@ _SYS_REL_TAG = "V3_STABLE_NZ"
 _SYS_MOD_KEY = "NZT-2026-CL"
 # ---------------------------
 
-# Excepciones espec├¡ficas
+# Excepciones espec├â┬¡ficas
 class FatalConnectionError(Exception):
-    """Se├▒ala p├®rdida de sesi├│n/driver; debe abortar toda la ejecuci├│n."""
+    """Se├â┬▒ala p├â┬®rdida de sesi├â┬│n/driver; debe abortar toda la ejecuci├â┬│n."""
     pass
 
 # Terceros
 from colorama import Fore, Style, init as colorama_init
 import pandas as pd
 
-# Local - Configuraci├│n
+# Local - Configuraci├â┬│n
 import sys
 # Dynamic Path Setup for "Mision Actual"
 _prj_root = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
@@ -84,7 +84,7 @@ from Mision_Actual import (
     REVISAR_HISTORIA_COMPLETA
 )
 
-# Imports tolerantes a fallos para nuevas variables (evita crash si Mision_Actual.py est├í desactualizado)
+# Imports tolerantes a fallos para nuevas variables (evita crash si Mision_Actual.py est├â┬í desactualizado)
 try:
     from C_Mision.Mision_Actual import FOLIO_VIH, FOLIO_VIH_CODIGOS
 except ImportError:
@@ -135,7 +135,7 @@ from src.core.Analisis_Misiones import FrequencyValidator, analizar_frecuencias
 colorama_init(autoreset=True)
 
 
-# Utilidad: recortar listas seg├║n l├¡mite configurado
+# Utilidad: recortar listas seg├â┬║n l├â┬¡mite configurado
 def _trim(seq: List[Any], n: Optional[int]) -> List[Any]:
     try:
         n_int = int(n) if n is not None else None
@@ -149,14 +149,14 @@ def _trim(seq: List[Any], n: Optional[int]) -> List[Any]:
 
 
 # =============================================================================
-#                         HELPERS DE CODIFICACI├ôN DE LISTAS
+#                         HELPERS DE CODIFICACI├âÔÇ£N DE LISTAS
 # =============================================================================
 
 def _parse_code_list(value: Any) -> List[str]:
     """
-    Convierte valores de configuraci├│n (lista, set, string, JSON, comma separated)
-    en una lista de c├│digos limpia.
-    Evita columnas fantasma cuando los campos vienen como '[]' o strings vac├¡os.
+    Convierte valores de configuraci├â┬│n (lista, set, string, JSON, comma separated)
+    en una lista de c├â┬│digos limpia.
+    Evita columnas fantasma cuando los campos vienen como '[]' o strings vac├â┬¡os.
     """
     if value is None:
         return []
@@ -191,38 +191,38 @@ def _parse_code_list(value: Any) -> List[str]:
 
 
 # =============================================================================
-#                    FUNCIONES DE AN├üLISIS DE MISI├ôN
+#                    FUNCIONES DE AN├â┬üLISIS DE MISI├âÔÇ£N
 # =============================================================================
 
 def seleccionar_caso_inteligente(casos_data: List[Dict[str, Any]], kws: List[str]) -> Optional[Dict[str, Any]]:
     """
-    Selecciona el mejor caso bas├índose en reglas de negocio inteligentes.
+    Selecciona el mejor caso bas├â┬índose en reglas de negocio inteligentes.
     
-    Aplica priorizaci├│n inteligente considerando:
+    Aplica priorizaci├â┬│n inteligente considerando:
     1. Coincidencia de keywords (filtro inicial)
     2. Estado del caso (Activo > Cerrado)
-    3. Problema de salud espec├¡fico
-    4. Fecha m├ís reciente
+    3. Problema de salud espec├â┬¡fico
+    4. Fecha m├â┬ís reciente
     
     Args:
-        casos_data: Lista de casos con informaci├│n completa.
+        casos_data: Lista de casos con informaci├â┬│n completa.
                    Cada caso debe contener: estado, nombre, fecha_apertura
         kws: Lista de keywords a buscar en el nombre del caso.
              Ejemplos: ["depresion", "trastorno depresivo"]
     
     Returns:
-        Dict con la informaci├│n del caso seleccionado, o None si no hay match.
+        Dict con la informaci├â┬│n del caso seleccionado, o None si no hay match.
         El diccionario contiene: {"estado": str, "nombre": str, "fecha": str, ...}
     
     Example:
-        >>> casos = [{"estado": "En Tratamiento", "nombre": "Depresi├│n", ...}]
+        >>> casos = [{"estado": "En Tratamiento", "nombre": "Depresi├â┬│n", ...}]
         >>> caso = seleccionar_caso_inteligente(casos, ["depresion"])
         >>> print(caso["estado"])  # "En Tratamiento"
     """
     candidatos = []
     
     # 1. Filtrar por Keywords
-    # Limpiar keywords para comparaci├│n
+    # Limpiar keywords para comparaci├â┬│n
     clean_kws = [str(k).strip().lower() for k in (kws or []) if k]
     
     for c in casos_data:
@@ -250,7 +250,7 @@ def seleccionar_caso_inteligente(casos_data: List[Dict[str, Any]], kws: List[str
     
     for c in candidatos:
         estado = str(c.get("estado", "")).lower()
-        # Detectar si est├í cerrado
+        # Detectar si est├â┬í cerrado
         es_cerrado = any(x in estado for x in ["cerrado", "cierre", "egreso", "finalizado"])
         es_activo = not es_cerrado
         
@@ -274,16 +274,16 @@ def seleccionar_caso_inteligente(casos_data: List[Dict[str, Any]], kws: List[str
 
 def buscar_inteligencia_historia(sigges, root, estado_caso: str) -> Dict[str, str]:
     """
-    Busca informaci├│n de inteligencia en el historial del caso para Apto SE.
+    Busca informaci├â┬│n de inteligencia en el historial del caso para Apto SE.
     
     Apto SE = "SI" si:
     - Estado del caso contiene "seguimiento"
-    - O alg├║n texto de OA/SIC contiene "seguimiento"
+    - O alg├â┬║n texto de OA/SIC contiene "seguimiento"
     
     Args:
         sigges: Objeto driver
-        root: Elemento ra├¡z del caso expandido
-        estado_caso: Estado actual del caso (para chequeo r├ípido)
+        root: Elemento ra├â┬¡z del caso expandido
+        estado_caso: Estado actual del caso (para chequeo r├â┬ípido)
         
     Returns:
         Dict con {"apto_se": "SI"/"NO", "obs_folio": "..."}
@@ -291,35 +291,35 @@ def buscar_inteligencia_historia(sigges, root, estado_caso: str) -> Dict[str, st
     es_apto_se = False
     estado_lower = (estado_caso or "").lower()
     
-    # 1. Chequeo r├ípido por estado actual
+    # 1. Chequeo r├â┬ípido por estado actual
     if "seguimiento" in estado_lower:
         es_apto_se = True
         
-    # Extraer TODAS las OAs (n=0) para an├ílisis profundo
-    # Retorna: fechas, derivados, diagn├│sticos, c├│digos, folios
+    # Extraer TODAS las OAs (n=0) para an├â┬ílisis profundo
+    # Retorna: fechas, derivados, diagn├â┬│sticos, c├â┬│digos, folios
     f, d, diag, c, folios_list = sigges.leer_oa_desde_caso(root, 0)
     
-    # Extraer TODAS las SICs (n=0) para an├ílisis profundo
+    # Extraer TODAS las SICs (n=0) para an├â┬ílisis profundo
     # Retorna: fechas, derivados
     f_sic, d_sic = sigges.leer_sic_desde_caso(root, 0)
 
-    # 2. B├║squeda de "Seguimiento" en historia (si no es apto a├║n)
+    # 2. B├â┬║squeda de "Seguimiento" en historia (si no es apto a├â┬║n)
     if not es_apto_se:
         kw = "seguimiento"
-        # Verificar Derivados y Diagn├│sticos (OA y SIC)
+        # Verificar Derivados y Diagn├â┬│sticos (OA y SIC)
         todos_textos = (d or []) + (diag or []) + (d_sic or [])
         for txt in todos_textos:
             if kw in (txt or "").lower():
                 es_apto_se = True
                 break
                 
-    # 3. B├║squeda Global de Folios
+    # 3. B├â┬║squeda Global de Folios
     obs_folio_parts = []
     targets = CODIGOS_FOLIO_BUSCAR if OBSERVACION_FOLIO_FILTRADA else []
     
     if targets and folios_list:
         for i, folio_num in enumerate(folios_list):
-            # Obtener c├│digo de la prestaci├│n
+            # Obtener c├â┬│digo de la prestaci├â┬│n
             codigo_oa = c[i] if i < len(c) else ""
             
             if codigo_oa in targets:
@@ -338,21 +338,21 @@ def buscar_inteligencia_historia(sigges, root, estado_caso: str) -> Dict[str, st
 
 def buscar_folio_vih(sigges, root, folio_vih_codigos: List[str]) -> str:
     """
-    Busca c├│digos VIH espec├¡ficos en OA y verifica si sus folios fueron usados en Prestaciones Otorgadas (PO).
-    Retorna el m├ís reciente de cada c├│digo.
+    Busca c├â┬│digos VIH espec├â┬¡ficos en OA y verifica si sus folios fueron usados en Prestaciones Otorgadas (PO).
+    Retorna el m├â┬ís reciente de cada c├â┬│digo.
     
     Flujo:
     1. Lee TODAS las OAs (n=0)
-    2. Filtra por c├│digos VIH especificados
+    2. Filtra por c├â┬│digos VIH especificados
     3. Lee tabla de Prestaciones Otorgadas (PO) para extraer referencias OA
-    4. Para cada c├│digo, verifica si el folio OA fue usado en PO
-    5. Guarda solo el m├ís reciente por cada c├│digo
+    4. Para cada c├â┬│digo, verifica si el folio OA fue usado en PO
+    5. Guarda solo el m├â┬ís reciente por cada c├â┬│digo
     6. Retorna formato: "codigo / fecha_oa / folio | codigo2 / fecha_oa / folio"
     
     Args:
         sigges: Objeto driver
-        root: Elemento ra├¡z del caso expandido
-        folio_vih_codigos: Lista de c├│digos a buscar (ej: ["0305091", "0305090", "9001043"])
+        root: Elemento ra├â┬¡z del caso expandido
+        folio_vih_codigos: Lista de c├â┬│digos a buscar (ej: ["0305091", "0305090", "9001043"])
         
     Returns:
         str: Formato "codigo / fecha / folio | codigo2 / fecha / folio" o "" si no hay coincidencias
@@ -360,18 +360,18 @@ def buscar_folio_vih(sigges, root, folio_vih_codigos: List[str]) -> str:
     if not folio_vih_codigos:
         return ""
     
-    # Normalizar c├│digos de b├║squeda
+    # Normalizar c├â┬│digos de b├â┬║squeda
     codigos_norm = {normalizar_codigo(c) for c in folio_vih_codigos if c}
     
     if not codigos_norm:
         return ""
     
     # 1. Leer TODAS las OAs (n=0 = todas las filas)
-    # Retorna: fechas, derivados, diagn├│sticos, c├│digos, folios
+    # Retorna: fechas, derivados, diagn├â┬│sticos, c├â┬│digos, folios
     try:
         f_oa, d_oa, diag_oa, c_oa, folios_oa = sigges.leer_oa_desde_caso(root, 0)
     except Exception as e:
-        log_warn(f"ÔØî No se pudieron leer OAs para Folio VIH: {e}")
+        log_warn(f"├ó┬Ø┼Æ No se pudieron leer OAs para Folio VIH: {e}")
         return ""
     
     if not folios_oa or not c_oa:
@@ -397,11 +397,11 @@ def buscar_folio_vih(sigges, root, folio_vih_codigos: List[str]) -> str:
         else:
             prestaciones_data = []
     except Exception as e:
-        log_warn(f"ÔØî No se pudieron leer Prestaciones Otorgadas para Folio VIH: {e}")
+        log_warn(f"├ó┬Ø┼Æ No se pudieron leer Prestaciones Otorgadas para Folio VIH: {e}")
         prestaciones_data = []
     
     # 3. Extraer referencias OA de prestaciones
-    # Las referencias tienen formato "OA 12246128", necesitamos solo el n├║mero
+    # Las referencias tienen formato "OA 12246128", necesitamos solo el n├â┬║mero
     refs_prestaciones = set()
     for prest in prestaciones_data:
         ref = prest.get("referencia", "") or ""
@@ -410,7 +410,7 @@ def buscar_folio_vih(sigges, root, folio_vih_codigos: List[str]) -> str:
         if ref_clean:
             refs_prestaciones.add(ref_clean)
     
-    # 4. Procesar OAs y filtrar por c├│digos VIH + verificar uso en prestaciones
+    # 4. Procesar OAs y filtrar por c├â┬│digos VIH + verificar uso en prestaciones
     # Diccionario: codigo_norm -> (fecha_oa_dt, folio, fecha_str, codigo_original)
     codigo_data = {}
     
@@ -420,12 +420,12 @@ def buscar_folio_vih(sigges, root, folio_vih_codigos: List[str]) -> str:
         if not codigo_oa:
             continue
         
-        # ┬┐Este c├│digo est├í en la lista de VIH?
+        # ├é┬┐Este c├â┬│digo est├â┬í en la lista de VIH?
         codigo_norm = normalizar_codigo(codigo_oa)
         if codigo_norm not in codigos_norm:
             continue
         
-        # ┬┐El folio est├í usado en Prestaciones Otorgadas?
+        # ├é┬┐El folio est├â┬í usado en Prestaciones Otorgadas?
         folio_clean = _norm(str(folio_num)).replace("oa", "").strip()
         if not (folio_clean and folio_clean in refs_prestaciones):
             continue
@@ -435,12 +435,12 @@ def buscar_folio_vih(sigges, root, folio_vih_codigos: List[str]) -> str:
         if not fecha_oa_str:
             continue
         
-        # Parsear fecha para comparaci├│n
+        # Parsear fecha para comparaci├â┬│n
         dt_oa = dparse(fecha_oa_str)
         if not dt_oa:
             continue
         
-        # Si ya ten├¡amos este c├│digo, quedarnos con el m├ís reciente
+        # Si ya ten├â┬¡amos este c├â┬│digo, quedarnos con el m├â┬ís reciente
         if codigo_norm in codigo_data:
             if dt_oa > codigo_data[codigo_norm][0]:
                 codigo_data[codigo_norm] = (dt_oa, folio_num, fecha_oa_str, codigo_oa)
@@ -466,8 +466,8 @@ def listar_habilitantes(prest: List[Dict[str, str]], cods: List[str],
     
     Args:
         prest: Lista de prestaciones {fecha, codigo, glosa, ref}
-        cods: C├│digos de habilitantes a buscar
-        fobj: Fecha de la n├│mina (para filtrar)
+        cods: C├â┬│digos de habilitantes a buscar
+        fobj: Fecha de la n├â┬│mina (para filtrar)
         mostrar_futuras: Si True, incluye prestaciones con fecha > fobj
         
     Returns:
@@ -496,12 +496,12 @@ def listar_habilitantes(prest: List[Dict[str, str]], cods: List[str],
 def listar_fechas_objetivo(prest: List[Dict[str, str]], cod: str, 
                            fobj: Optional[datetime]) -> List[datetime]:
     """
-    Lista todas las fechas de un c├│digo de objetivo.
+    Lista todas las fechas de un c├â┬│digo de objetivo.
     
     Args:
         prest: Lista de prestaciones
-        cod: C├│digo del objetivo
-        fobj: Fecha de la n├│mina
+        cod: C├â┬│digo del objetivo
+        fobj: Fecha de la n├â┬│mina
         
     Returns:
         Lista de fechas ordenadas desc
@@ -523,7 +523,7 @@ def listar_fechas_objetivo(prest: List[Dict[str, str]], cod: str,
 
 
 def get_objetivos_config(m: Dict[str, Any]) -> List[str]:
-    """Obtiene lista de c├│digos de objetivos de una misi├│n."""
+    """Obtiene lista de c├â┬│digos de objetivos de una misi├â┬│n."""
     objs = _parse_code_list(m.get("objetivos", []))
     if not objs and m.get("objetivo"):
         objs = _parse_code_list(m.get("objetivo"))
@@ -532,8 +532,8 @@ def get_objetivos_config(m: Dict[str, Any]) -> List[str]:
 
 def cols_mision(m: Dict[str, Any]) -> List[str]:
     """
-    Genera lista de columnas para el Excel de una misi├│n.
-    Columnas din├ímicas seg├║n la configuraci├│n de la misi├│n.
+    Genera lista de columnas para el Excel de una misi├â┬│n.
+    Columnas din├â┬ímicas seg├â┬║n la configuraci├â┬│n de la misi├â┬│n.
     NOTA: Nombre se mantiene solo en terminal, no en Excel.
     """
     req_ipd = m.get("require_ipd", REVISAR_IPD)
@@ -543,22 +543,24 @@ def cols_mision(m: Dict[str, Any]) -> List[str]:
     req_eleccion = bool(m.get("requiere_ipd") or m.get("requiere_aps"))
     has_contra = bool(m.get("keywords_contra"))
 
-    cols = ["Fecha", "Rut", "Edad"]
+    cols = ["Fecha", "Rut", "Edad", "Estado", "Tipo"]
 
-    # Columnas de objetivos (din├ímicas - solo si hay objetivos definidos)
+    # Columnas de objetivos (din├â┬ímicas - solo si hay objetivos definidos)
     objetivos_cfg = get_objetivos_config(m)
-    num_objetivos = len(objetivos_cfg) if objetivos_cfg else 0
-    for i in range(num_objetivos):
-        cols.append(f"F Obj {i+1}")
+    max_objs = int(m.get("max_objetivos", 10))
+    # Respetar Max Obj y evitar columnas extras
+    num_objetivos = min(len(objetivos_cfg), max_objs) if objetivos_cfg else 0
 
+    for i in range(num_objetivos):
+        cols.append(f"Objetivo {i+1}")
     add_mensual = bool(objetivos_cfg) or bool(m.get("anios_codigo"))
 
     # Columnas de caso (nombres actualizados)
     # Apto SE = Seguimiento (estado o historial OA/SIC)
-    # Apto RE = Resoluci├│n/Evaluaci├│n (IPD con S├¡ o APS/OA creados)
+    # Apto RE = Resoluci├â┬│n/Evaluaci├â┬│n (IPD con S├â┬¡ o APS/OA creados)
     cols += [
         "Familia", "Especialidad", "Fallecido",
-        "Caso", "Estado", "Apertura", "┬┐Cerrado?"
+        "Caso", "Apertura", "├é┬┐Cerrado?"
     ]
 
     # --- REORDENAMIENTO SOLICITADO: Habilitantes y Excluyentes PRIMERO ---
@@ -583,29 +585,32 @@ def cols_mision(m: Dict[str, Any]) -> List[str]:
     show_apto_strict = req_ipd or req_oa or req_aps or req_sic or req_eleccion or has_contra
 
     if show_apto_strict:
-        cols += ["Apto SE", "Apto RE", "Apto Caso"]
+        cols += ["Apto SE", "Apto RE"]
+        # "Apto Caso" SOLO si hay caso en contra configurado
+        if has_contra:
+            cols.append("Apto Caso")
         if req_eleccion:
             try:
                 idx_se = cols.index("Apto SE")
-                cols.insert(idx_se, "Apto Elecci├│n")
+                cols.insert(idx_se, "Apto Elecci├â┬│n")
             except ValueError:
-                cols.append("Apto Elecci├│n")
+                cols.append("Apto Elecci├â┬│n")
 
-    # FRECUENCIAS DIN├üMICAS (Nuevo Sistema) - Inyectar JUSTO DESPU├ëS de columnas base
+    # FRECUENCIAS DIN├â┬üMICAS (Nuevo Sistema) - Inyectar JUSTO DESPU├âÔÇ░S de columnas base
     
-    # 1. C├│digos por A├▒o (si est├í activo)
-    # Orden solicitado: CodxA├▒o, Freq CodxA├▒o, Period CodxA├▒o
+    # 1. C├â┬│digos por A├â┬▒o (si est├â┬í activo)
+    # Orden solicitado: CodxA├â┬▒o, Freq CodxA├â┬▒o, Period CodxA├â┬▒o
     anios_coded = False
     if m.get("active_year_codes"):
-        # Solo agregar columna fija si se activ├│ la opci├│n
-        # (El valor se rellena din├ímicamente en analizar_mision)
-        cols.append("CodxA├▒o")      # Nombre estricto
-        cols.append("Freq CodxA├▒o")   # Nombre estricto
-        cols.append("Period CodxA├▒o") # Nombre estricto (antes PeriodxA├▒o)
+        # Solo agregar columna fija si se activ├â┬│ la opci├â┬│n
+        # (El valor se rellena din├â┬ímicamente en analizar_mision)
+        cols.append("CodxA├â┬▒o")      # Nombre estricto
+        cols.append("Freq CodxA├â┬▒o")   # Nombre estricto
+        cols.append("Period CodxA├â┬▒o") # Nombre estricto (antes PeriodxA├â┬▒o)
         anios_coded = True
 
     # 2. Reglas de Frecuencia Configuradas (Freq {CODE}, Period {CODE})
-    # Analizar qu├® reglas existen para crear las columnas correspondientes
+    # Analizar qu├â┬® reglas existen para crear las columnas correspondientes
     detected_codes = set()
     
     # A) Desde 'frecuencias' (List Editor)
@@ -621,7 +626,7 @@ def cols_mision(m: Dict[str, Any]) -> List[str]:
         for o in objs:
              detected_codes.add(o)
 
-    # Ordenar c├│digos para consistencia
+    # Ordenar c├â┬│digos para consistencia
     for c in sorted(list(detected_codes)):
         cols.append(f"Freq {c}")   # Nombre estricto (coincide con analizar_mision)
         cols.append(f"Period {c}") # Nombre estricto (coincide con analizar_mision)
@@ -644,19 +649,19 @@ def cols_mision(m: Dict[str, Any]) -> List[str]:
         for o in objs:
              detected_codes.add(o)
 
-    # C) Desde 'anios_codigo' (si est├í activo, cada c├│digo posible genera columna??)
-    # NO, el usuario quiere una sola columna "Freq CodxA├▒o", no una por cada a├▒o posible.
-    # PERO el validador genera "FREQ_RES_{code}" para el c├│digo seleccionado.
-    # Si queremos ver el detalle t├®cnico, agregamos las columnas. 
-    # Si solo queremos la version resumida "Freq CodxA├▒o", ok.
+    # C) Desde 'anios_codigo' (si est├â┬í activo, cada c├â┬│digo posible genera columna??)
+    # NO, el usuario quiere una sola columna "Freq CodxA├â┬▒o", no una por cada a├â┬▒o posible.
+    # PERO el validador genera "FREQ_RES_{code}" para el c├â┬│digo seleccionado.
+    # Si queremos ver el detalle t├â┬®cnico, agregamos las columnas. 
+    # Si solo queremos la version resumida "Freq CodxA├â┬▒o", ok.
     # El usuario dijo: "Modifying the Excel report to include dynamic columns for each configured frequency code."
-    # As├¡ que S├ì debemos agregar las columnas din├ímicas para todo lo que est├® en 'anios_codigo' tambi├®n?
-    # Mejor agregamos columnas para todo lo que est├® configurado expl├¡citamente en 'frecuencias'
-    # y confiamos en que 'Freq CodxA├▒o' cubra la parte de a├▒os.
+    # As├â┬¡ que S├â┬ì debemos agregar las columnas din├â┬ímicas para todo lo que est├â┬® en 'anios_codigo' tambi├â┬®n?
+    # Mejor agregamos columnas para todo lo que est├â┬® configurado expl├â┬¡citamente en 'frecuencias'
+    # y confiamos en que 'Freq CodxA├â┬▒o' cubra la parte de a├â┬▒os.
     
-    # D) Agregamos tambi├®n los c├│digos de a├▒os al pool de columnas din├ímicas?
-    # Si el usuario configura 10 a├▒os, tener 20 columnas vac├¡as es feo.
-    # Dejemos solo 'Freq CodxA├▒o' para la l├│gica de a├▒os, y 'FREQ_...' para reglas explicitas.
+    # D) Agregamos tambi├â┬®n los c├â┬│digos de a├â┬▒os al pool de columnas din├â┬ímicas?
+    # Si el usuario configura 10 a├â┬▒os, tener 20 columnas vac├â┬¡as es feo.
+    # Dejemos solo 'Freq CodxA├â┬▒o' para la l├â┬│gica de a├â┬▒os, y 'FREQ_...' para reglas explicitas.
     
     # (Legacy loop removed - moved above for correct ordering)
     pass
@@ -667,27 +672,27 @@ def cols_mision(m: Dict[str, Any]) -> List[str]:
         # cols.append("Periodicidad")
         pass
         
-    # FIX: C├│digo A├▒o already added above
+    # FIX: C├â┬│digo A├â┬▒o already added above
     pass
     
-    # (Tablas cl├¡nicas siguen ac├í abajo...)
+    # (Tablas cl├â┬¡nicas siguen ac├â┬í abajo...)
     if req_ipd:
-        cols += ["Fecha IPD", "Estado IPD", "Diagn├│stico IPD"]
+        cols += ["Fecha IPD", "Estado IPD", "Diagn├â┬│stico IPD"]
     if req_oa:
-        cols += ["C├│digo OA", "Fecha OA", "Folio OA", "Derivado OA", "Diagn├│stico OA"]
+        cols += ["C├â┬│digo OA", "Fecha OA", "Folio OA", "Derivado OA", "Diagn├â┬│stico OA"]
     if req_aps:
         cols += ["Fecha APS", "Estado APS"]
     if req_sic:
         cols += ["Fecha SIC", "Derivado SIC"]
 
-    # Observaci├│n: solo para fallecimiento u otros datos cr├¡ticos
-    cols.append("Observaci├│n")
+    # Observaci├â┬│n: solo para fallecimiento u otros datos cr├â┬¡ticos
+    cols.append("Observaci├â┬│n")
     
-    # Observaci├│n Folio: solo si revisamos OA (misi├│n-espec├¡fico)
+    # Observaci├â┬│n Folio: solo si revisamos OA (misi├â┬│n-espec├â┬¡fico)
     if req_oa:
-        cols.append("Observaci├│n Folio")
+        cols.append("Observaci├â┬│n Folio")
         
-        # Folio VIH: solo si est├í activado Y revisamos OA
+        # Folio VIH: solo si est├â┬í activado Y revisamos OA
         if m.get("folio_vih", False):
             cols.append("Folio VIH")
 
@@ -696,7 +701,7 @@ def cols_mision(m: Dict[str, Any]) -> List[str]:
         cols += [
             "Caso en Contra", "Estado en Contra", "Apertura en Contra",
             "Estado IPD en Contra", "Fecha IPD en Contra", "Diag IPD en Contra",
-            "C├│digo OA en Contra", "Fecha OA en Contra", "Folio OA en Contra", "Derivado OA en Contra", "Diagn├│stico OA en Contra",
+            "C├â┬│digo OA en Contra", "Fecha OA en Contra", "Folio OA en Contra", "Derivado OA en Contra", "Diagn├â┬│stico OA en Contra",
             "Fecha APS en Contra", "Estado APS en Contra",
             "Fecha SIC en Contra", "Derivado SIC en Contra"
         ]
@@ -709,22 +714,22 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
                     fall_dt: Optional[datetime], edad_paciente: Optional[int],
                     rut: str, nombre: str, caso_info: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
     """
-    Analiza una misi├│n espec├¡fica para un paciente.
+    Analiza una misi├â┬│n espec├â┬¡fica para un paciente.
     
-    Este es el coraz├│n del an├ílisis - lee prestaciones, busca objetivos,
+    Este es el coraz├â┬│n del an├â┬ílisis - lee prestaciones, busca objetivos,
     habilitantes, excluyentes, IPD, OA, APS y genera todas las observaciones.
     
     Args:
-        caso_info: Dict con informaci├│n del caso de la mini-tabla (estado, fechas, etc.)
+        caso_info: Dict con informaci├â┬│n del caso de la mini-tabla (estado, fechas, etc.)
     """
-    # Flags y l├¡mites por misi├│n (fallback a configuraciones globales)
+    # Flags y l├â┬¡mites por misi├â┬│n (fallback a configuraciones globales)
     req_ipd = bool(m.get("require_ipd", REVISAR_IPD))
     req_oa = bool(m.get("require_oa", REVISAR_OA))
     req_aps = bool(m.get("require_aps", REVISAR_APS))
     req_sic = bool(m.get("require_sic", REVISAR_SIC))
     req_eleccion_ipd = bool(m.get("requiere_ipd"))
     req_eleccion_aps = bool(m.get("requiere_aps"))
-    req_eleccion = bool(req_eleccion_ipd or req_eleccion_aps) # FIX: Definir req_eleccion expl├¡citamente
+    req_eleccion = bool(req_eleccion_ipd or req_eleccion_aps) # FIX: Definir req_eleccion expl├â┬¡citamente
     tiene_contra = bool(m.get("keywords_contra"))
     
     # Manejo robusto de anios_codigo (puede ser list[str] legacy o list[dict] nuevo)
@@ -735,7 +740,7 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
              if isinstance(x, dict):
                  anios_codigo_cfg.append(x) # Nuevo formato
              else:
-                 anios_codigo_cfg.append({"code": str(x).strip(), "qty": 1, "type": "Mes", "period_label": "Mensual"}) # Adaptaci├│n Legacy
+                 anios_codigo_cfg.append({"code": str(x).strip(), "qty": 1, "type": "Mes", "period_label": "Mensual"}) # Adaptaci├â┬│n Legacy
     else:
         # Fallback string parsing
         tmp = _parse_code_list(anios_codigo_raw)
@@ -752,7 +757,7 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
 
     res = vac_row(m, fecha, rut, nombre, "")
     
-    # --- INICIALIZACI├ôN COMPLETA DE COLUMNAS ---
+    # --- INICIALIZACI├âÔÇ£N COMPLETA DE COLUMNAS ---
     # Esto asegura que todos los campos del Excel existan en el dict,
     # evitando errores de "KeyError" o "if key in res" que fallan silenciamente.
     all_cols = cols_mision(m)
@@ -782,12 +787,12 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
     res["Caso"] = caso_seleccionado.get("caso", "")
     res["Estado"] = caso_seleccionado.get("estado", "")
     res["Apertura"] = caso_seleccionado.get("apertura", "")
-    res["┬┐Cerrado?"] = caso_seleccionado.get("cierre", "NO")
-    res["Fallecido"] = "S├¡" if fall_dt else "No"
+    res["├é┬┐Cerrado?"] = caso_seleccionado.get("cierre", "NO")
+    res["Fallecido"] = "S├â┬¡" if fall_dt else "No"
     apertura_principal_dt = dparse(res["Apertura"]) if res.get("Apertura") else None
     # -------------------------------------------------------------------------
-    # NOTA: La l├│gica de 'C├│digo A├▒o' y 'Periodicidad' se calcula m├ís adelante,
-    # una vez que se han extra├¡do las fechas IPD reales.
+    # NOTA: La l├â┬│gica de 'C├â┬│digo A├â┬▒o' y 'Periodicidad' se calcula m├â┬ís adelante,
+    # una vez que se han extra├â┬¡do las fechas IPD reales.
     # Se ha eliminado el bloque prematuro que causaba conflictos.
     # -------------------------------------------------------------------------
     
@@ -808,26 +813,26 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
     folios_oa_encontrados = []
     
     # =========================================================================
-    # ­ƒºá INTELIGENCIA DE HISTORIA (APTO SE + FOLIOS GLOBALES)
+    # ├░┼©┬º┬á INTELIGENCIA DE HISTORIA (APTO SE + FOLIOS GLOBALES)
     # =========================================================================
     try:
         intel_data = buscar_inteligencia_historia(sigges, root, res["Estado"])
         res["Apto SE"] = intel_data["apto_se"]
         
-        # Si hay observaci├│n de folios globales encontrada, la usamos prioritariamente
+        # Si hay observaci├â┬│n de folios globales encontrada, la usamos prioritariamente
         if intel_data["obs_folio"]:
-            res["Observaci├│n Folio"] = intel_data["obs_folio"]
+            res["Observaci├â┬│n Folio"] = intel_data["obs_folio"]
             
     except Exception as e:
         log_warn(f"Fallo inteligencia historia (Apto SE): {e}")
         res["Apto SE"] = "Error"
 
-    # Variables para calcular Apto RE despu├®s
+    # Variables para calcular Apto RE despu├â┬®s
     ipd_tiene_si = False
     aps_tiene_registros = False
     
     try:
-        # ­ƒöì DEBUG: Verificar flags de lectura
+        # ├░┼©ÔÇØ┬ì DEBUG: Verificar flags de lectura
         log_debug(f"[DEBUG] analizar_mision: req_ipd={req_ipd}, req_oa={req_oa}, req_aps={req_aps}, req_sic={req_sic}")
         # ===== IPD =====
         if req_ipd:
@@ -843,16 +848,16 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
             try:
                 res["Fecha IPD"] = join_clean(f_list)
                 res["Estado IPD"] = join_clean(e_list)
-                res["Diagn├│stico IPD"] = join_clean(d_list)
-                log_warn(f"­ƒôó DIAGNOSTICO IPD: Fecha='{res['Fecha IPD']}' Estado='{res['Estado IPD']}'")
+                res["Diagn├â┬│stico IPD"] = join_clean(d_list)
+                log_warn(f"├░┼©ÔÇ£┬ó DIAGNOSTICO IPD: Fecha='{res['Fecha IPD']}' Estado='{res['Estado IPD']}'")
             except Exception as e_diag:
-                log_error(f"ÔØî ERROR DIAGNOSTICO IPD: {e_diag}")
+                log_error(f"├ó┬Ø┼Æ ERROR DIAGNOSTICO IPD: {e_diag}")
             ipd_estados_list = e_list[:]
             ipd_fecha_dt = dparse(f_list[0]) if f_list and f_list[0] else None
             
-            # ­ƒöì Verificar si alg├║n estado IPD contiene "S├¡" para Apto RE
+            # ├░┼©ÔÇØ┬ì Verificar si alg├â┬║n estado IPD contiene "S├â┬¡" para Apto RE
             for estado in e_list:
-                if estado and ("s├¡" in estado.lower() or "si" in estado.lower()):
+                if estado and ("s├â┬¡" in estado.lower() or "si" in estado.lower()):
                     ipd_tiene_si = True
                     break
             
@@ -879,14 +884,14 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
             try:
                 res["Fecha OA"] = join_clean(f_oa)
                 res["Derivado OA"] = join_clean(p_oa)
-                res["Diagn├│stico OA"] = join_clean(d_oa)
-                res["C├│digo OA"] = join_clean(c_oa)
+                res["Diagn├â┬│stico OA"] = join_clean(d_oa)
+                res["C├â┬│digo OA"] = join_clean(c_oa)
                 res["Folio OA"] = join_clean(fol_oa)
-                # log_warn(f"­ƒôó DIAGNOSTICO OA: Fecha='{res['Fecha OA']}' Codigo='{res['C├│digo OA']}'")
+                # log_warn(f"├░┼©ÔÇ£┬ó DIAGNOSTICO OA: Fecha='{res['Fecha OA']}' Codigo='{res['C├â┬│digo OA']}'")
             except Exception as e_diag:
-                log_error(f"ÔØî ERROR DIAGNOSTICO OA: {e_diag}")
+                log_error(f"├ó┬Ø┼Æ ERROR DIAGNOSTICO OA: {e_diag}")
 
-            # Guardar folios para an├ílisis posterior
+            # Guardar folios para an├â┬ílisis posterior
             for i_f, fol in enumerate(fol_oa or []):
                 try:
                     if fol and i_f < len(f_oa) and f_oa[i_f]:
@@ -915,13 +920,13 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
             try:
                 res["Fecha APS"] = join_clean(f_aps)
                 res["Estado APS"] = join_clean(e_aps)
-                log_warn(f"­ƒôó DIAGNOSTICO APS: Fecha='{res['Fecha APS']}' Estado='{res['Estado APS']}'")
+                log_warn(f"├░┼©ÔÇ£┬ó DIAGNOSTICO APS: Fecha='{res['Fecha APS']}' Estado='{res['Estado APS']}'")
             except Exception as e_diag:
-                log_error(f"ÔØî ERROR DIAGNOSTICO APS: {e_diag}")
+                log_error(f"├ó┬Ø┼Æ ERROR DIAGNOSTICO APS: {e_diag}")
             aps_estados_list = e_aps[:]
             aps_fecha_dt = dparse(f_aps[0]) if f_aps and f_aps[0] else None
             
-            # ­ƒöì Verificar si existe al menos un registro APS para Apto RE
+            # ├░┼©ÔÇØ┬ì Verificar si existe al menos un registro APS para Apto RE
             if f_aps and len(f_aps) > 0 and any(f.strip() for f in f_aps):
                 aps_tiene_registros = True
             
@@ -941,9 +946,9 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
             try:
                 res["Fecha SIC"] = join_clean(f_sic)
                 res["Derivado SIC"] = join_clean(d_sic)
-                log_warn(f"­ƒôó DIAGNOSTICO SIC: Fecha='{res['Fecha SIC']}' Derivado='{res['Derivado SIC']}'")
+                log_warn(f"├░┼©ÔÇ£┬ó DIAGNOSTICO SIC: Fecha='{res['Fecha SIC']}' Derivado='{res['Derivado SIC']}'")
             except Exception as e_diag:
-                log_error(f"ÔØî ERROR DIAGNOSTICO SIC: {e_diag}")
+                log_error(f"├ó┬Ø┼Æ ERROR DIAGNOSTICO SIC: {e_diag}")
             t1 = time.time()
             dt = (t1-t0)*1000
             if should_show_timing():
@@ -973,11 +978,11 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
             print(f"{Fore.LIGHTBLACK_EX}  - Cerrar caso -> {dt:.0f}ms{Style.RESET_ALL}")
     
     # =========================================================================
-    # ­ƒôå C├üLCULO DE C├ôDIGO POR A├æO (Moved Up for Frequency Analysis)
+    # ├░┼©ÔÇ£ÔÇá C├â┬üLCULO DE C├âÔÇ£DIGO POR A├âÔÇÿO (Moved Up for Frequency Analysis)
     # =========================================================================
     if m.get("active_year_codes") and anios_codigo_cfg:
         try:
-            # L├│gica: ├ìndice = A├▒o Objetivo - A├▒o IPD (Antig├╝edad)
+            # L├â┬│gica: ├â┬ìndice = A├â┬▒o Objetivo - A├â┬▒o IPD (Antig├â┬╝edad)
             year_diff = 0
             # Preferencia de antiguedad: IPD > APS > Apertura Caso
             start_date = ipd_fecha_dt or aps_fecha_dt or apertura_principal_dt
@@ -985,23 +990,23 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
             if fobj and start_date:
                 year_diff = fobj.year - start_date.year
             
-            # Asegurar ├¡ndice v├ílido
+            # Asegurar ├â┬¡ndice v├â┬ílido
             idx_code = max(0, min(year_diff, len(anios_codigo_cfg) - 1))
             
             selected_year_code = anios_codigo_cfg[idx_code]
             
-            # Inyectar al resultado (solo el c├│digo string para visualizaci├│n simple)
+            # Inyectar al resultado (solo el c├â┬│digo string para visualizaci├â┬│n simple)
             code_str = selected_year_code.get("code", "")
-            if "C├│digo A├▒o" in res:
-                 res["C├│digo A├▒o"] = code_str
+            if "C├â┬│digo A├â┬▒o" in res:
+                 res["C├â┬│digo A├â┬▒o"] = code_str
                  
-            log_debug(f"­ƒôà C├│digo A├▒o Calc: Diff={year_diff} (Obj:{fobj.year if fobj else '?'} - Start:{start_date.year if start_date else '?'}) -> Idx={idx_code} Code={code_str}")
+            log_debug(f"├░┼©ÔÇ£ÔÇª C├â┬│digo A├â┬▒o Calc: Diff={year_diff} (Obj:{fobj.year if fobj else '?'} - Start:{start_date.year if start_date else '?'}) -> Idx={idx_code} Code={code_str}")
         except Exception as e_code:
-            log_warn(f"Error calculando C├│digo A├▒o: {e_code}")
+            log_warn(f"Error calculando C├â┬│digo A├â┬▒o: {e_code}")
             pass
 
     # =========================================================================
-    # ­ƒºá APTO RE (IPD con S├¡, APS confirmado o OA en tratamiento)
+    # ├░┼©┬º┬á APTO RE (IPD con S├â┬¡, APS confirmado o OA en tratamiento)
     # =========================================================================
     oa_trat = any((d or "").lower().find("caso en tratamiento") >= 0 for d in oa_derivados_list)
     # APS Positivo: Confirmado, Sospecha o Tratamiento
@@ -1018,9 +1023,9 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
     else:
         res["Apto RE"] = "NO"
 
-    # ­ƒºá APTO ELECCI├ôN (requiere_ipd / requiere_aps)
-    # FORZAR chequeo si se requiere elecci├│n, aunque vac_row no lo haya creado
-    if req_eleccion or "Apto Elecci├│n" in res:
+    # ├░┼©┬º┬á APTO ELECCI├âÔÇ£N (requiere_ipd / requiere_aps)
+    # FORZAR chequeo si se requiere elecci├â┬│n, aunque vac_row no lo haya creado
+    if req_eleccion or "Apto Elecci├â┬│n" in res:
         ipd_pos = ipd_tiene_si
         aps_pos = aps_confirmado
         if req_eleccion_ipd:
@@ -1031,10 +1036,10 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
             aps_txt = "SI APS" if aps_pos else "NO APS"
         else:
             aps_txt = "NO REQ APS"
-        res["Apto Elecci├│n"] = f"{ipd_txt} | {aps_txt}"
+        res["Apto Elecci├â┬│n"] = f"{ipd_txt} | {aps_txt}"
 
-    # Recalcular C├│digo A├▒o (ELIMINADO - MOVIDO ARRIBA)
-    # Ya se calcul├│ antes para ser usado en Frecuencias
+    # Recalcular C├â┬│digo A├â┬▒o (ELIMINADO - MOVIDO ARRIBA)
+    # Ya se calcul├â┬│ antes para ser usado en Frecuencias
     pass
 
     # ===== CASO EN CONTRA / APTO CASO =====
@@ -1058,10 +1063,10 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
             contra_ipd_pos = False
             contra_aps_pos = False
             try:
-                log_debug(f"­ƒöì Expandiendo Caso en Contra idx={contra_case.get('indice', 0)}")
+                log_debug(f"├░┼©ÔÇØ┬ì Expandiendo Caso en Contra idx={contra_case.get('indice', 0)}")
                 root_c = sigges.expandir_caso(contra_case.get("indice", 0))
                 if root_c:
-                    log_debug(f"Ô£à Caso en Contra expandido. Flags originales: req_ipd={req_ipd}, req_aps={req_aps} -> FORZANDO LECTURA para Contra")
+                    log_debug(f"├ó┼ôÔÇª Caso en Contra expandido. Flags originales: req_ipd={req_ipd}, req_aps={req_aps} -> FORZANDO LECTURA para Contra")
                     
                     # === IPD CONTRA ===
                     try:
@@ -1074,7 +1079,7 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
                         res["Diag IPD en Contra"] = join_clean(d_ipd_c)
                         
                         contra_ipd_dt = dparse(f_ipd_c[0]) if f_ipd_c and f_ipd_c[0] else None
-                        contra_ipd_pos = any("si" in (s or "").lower() or "s├¡" in (s or "").lower() for s in e_ipd_c)
+                        contra_ipd_pos = any("si" in (s or "").lower() or "s├â┬¡" in (s or "").lower() for s in e_ipd_c)
                     except Exception as e_ipd_c:
                         log_warn(f"Error IPD Contra: {e_ipd_c}")
 
@@ -1088,10 +1093,10 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
                         fol_oa_c = _trim(fol_oa_c, filas_oa)
                         
                         res["Fecha OA en Contra"] = join_clean(f_oa_c)
-                        res["C├│digo OA en Contra"] = join_clean(c_oa_c)
+                        res["C├â┬│digo OA en Contra"] = join_clean(c_oa_c)
                         res["Folio OA en Contra"] = join_clean(fol_oa_c)
                         res["Derivado OA en Contra"] = join_clean(p_oa_c)
-                        res["Diagn├│stico OA en Contra"] = join_clean(d_oa_c)
+                        res["Diagn├â┬│stico OA en Contra"] = join_clean(d_oa_c)
                     except Exception as e_oa_c:
                         log_warn(f"Error OA Contra: {e_oa_c}")
 
@@ -1120,12 +1125,12 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
                     except Exception as e_sic_c:
                         log_warn(f"Error SIC Contra: {e_sic_c}")
                 else:
-                    log_warn("ÔØî No se pudo obtener root_c para Caso en Contra")
+                    log_warn("├ó┬Ø┼Æ No se pudo obtener root_c para Caso en Contra")
 
                 if root_c:
                     sigges.cerrar_caso_por_indice(contra_case.get("indice", 0))
             except Exception as e_contra:
-                log_error(f"ÔØî Error leyendo detalles Caso en Contra: {e_contra}")
+                log_error(f"├ó┬Ø┼Æ Error leyendo detalles Caso en Contra: {e_contra}")
                 pass
 
             tokens_caso = []
@@ -1137,31 +1142,27 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
                 tokens_caso.append("Apertura + Reciente")
             res["Apto Caso"] = " | ".join(tokens_caso) if tokens_caso else "No"
 
-    # ===== OBJETIVOS =====
     # ===== OBJETIVOS =====
     objetivos_cfg = get_objetivos_config(m)
 
-    # Buscar fechas de cada objetivo
-
     # Buscar fechas de cada objetivo
     obj_info = []
     for cod in objetivos_cfg:
         dts = listar_fechas_objetivo(prestaciones, cod, fobj)
         obj_info.append((cod, dts))
 
-    # Ordenar por fecha m├ís reciente
+    # Ordenar por fecha m├â┬ís reciente
     obj_info.sort(key=lambda x: x[1][0] if x[1] else datetime.min, reverse=True)
     
-    # Limitar objetivos seg├║n configuraci├│n
+    # Limitar objetivos seg├â┬║n configuraci├â┬│n (y guardar info)
     obj_info = obj_info[:max_objs]
 
     fechas_obj_all = []
-    # Solo crear columnas para los objetivos que realmente existen en la configuraci├│n
-    fechas_obj_all = []
-    # Solo crear columnas para los objetivos que realmente existen en la configuraci├│n
-    num_objetivos = len(objetivos_cfg)
+    # Solo crear columnas para los objetivos que realmente existen en la configuraci├â┬│n (Respetando Max Obj)
+    num_objetivos = min(len(objetivos_cfg), max_objs)
+    
     for i in range(num_objetivos):
-        col = f"F Obj {i+1}"
+        col = f"Objetivo {i+1}"
         if i < len(obj_info):
             _, dts = obj_info[i]
             if dts:
@@ -1172,124 +1173,88 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
         else:
             res[col] = ""
 
-    # Mensual / Frecuencia (NUEVA L├ôGICA V2)
+    # Mensual / Frecuencia (NUEVA L├âÔÇ£GICA V2)
     try:
         # 1. Preparar lista de reglas
         freq_rules = []
-        
-        # A) Reglas Generales (FrequencyListEditor)
-        # Asumimos que m["frecuencias"] es la lista de dicts nueva.
-        # Si no existe, usamos fallback legacy de m["frecuencia"], m["frecuencia_cantidad"], etc.
+
+        # A) Reglas desde "frecuencias" (List Editor)
         general_freqs = m.get("frecuencias", [])
-        if not general_freqs and m.get("frecuencia"):
-             # Fallback Legacy
-             period_lbl = m.get("periodicidad", "") or m.get("frecuencia", "").capitalize()
-             qty = 1
-             try: qty = int(m.get("frecuencia_cantidad", 1))
-             except: pass
-             
-             # Intentar adivinar tipo
-             ftype = "Mes"
-             txt = m.get("frecuencia", "").lower()
-             if "a├▒o" in txt or "anio" in txt: ftype = "A├▒o"
-             elif "vida" in txt or "cada" in txt: ftype = "Vida"
-             
-             # Usar objetivos como c├│digos
-             codigos = get_objetivos_config(m)
-             # Crear una regla por c├│digo (o agrupada? El legacy usaba "target_codes" en grupo)
-             # Analizar_Misiones legacy l├│gica agrupaba.
-             # Pero FrequencyValidator es por regla.
-             for c in codigos:
-                 freq_rules.append({
-                     "code": c,
-                     "qty": qty,
-                     "type": ftype,
-                     "period_label": period_lbl
-                 })
-
-        elif general_freqs:
-             # Formato nuevo: List[Dict]
-             freq_rules.extend(general_freqs)
-
-        # B) Regla por A├▒o (Si aplica)
-        if selected_year_code:
-            # selected_year_code ya es un dict {"code":..., "qty":..., "type":...}
-            freq_rules.append(selected_year_code)
-            
-        # 2. Ejecutar An├ílisis
-        if freq_rules and prestaciones and fobj:
-            # Llamar al motor centralizado
-            # FIX: No usamos analizar_frecuencias (wrapper) porque espera 'mision' dict.
-            # Usamos FrequencyValidator directo iterando nuestras reglas ya preparadas.
-            
-            # OPTIMIZACI├ôN: Pre-procesar todas las prestaciones 1 sola vez
-            # Convertir fechas string a date objects y asegurar codigo_limpio
-            # Esto evita re-parsiar la fecha N veces (N = num_reglas)
-            prestaciones_opt = []
-            for p in prestaciones:
-                p_opt = p.copy() # Shallow copy
-                
-                # Code
-                if "codigo_limpio" not in p_opt:
-                     p_opt["codigo_limpio"] = normalizar_codigo(p.get("codigo", ""))
-                     
-                # Date
-                f_raw = p.get("fecha")
-                if f_raw and isinstance(f_raw, str):
-                     d_parsed = dparse(f_raw) # Usa dparse de Formatos.py
-                     if d_parsed:
-                         p_opt["fecha"] = d_parsed.date() # FrequencyValidator usa .year/.month
-                     else:
-                         p_opt["fecha"] = None
-                elif isinstance(f_raw, datetime):
-                     p_opt["fecha"] = f_raw.date()
-                
-                prestaciones_opt.append(p_opt)
-            
-            resultados_freq = {}
-            for rule in freq_rules:
-                # rule es un dict {code, qty, type...}
-                c = rule.get("code")
-                if not c: continue
-                
-                # Usar lista optimizada
-                try:
-                    res_val = FrequencyValidator.validar(prestaciones_opt, rule, fobj)
-                    resultados_freq[f"FREQ_{c}"] = res_val
-                except Exception as e_rule:
-                    log_warn(f"ÔÜá´©Å Error validando regla freq '{c}': {e_rule}")
-                    # Agregar resultado de error para visualizaci├│n
-                    resultados_freq[f"FREQ_{c}"] = {
-                        "result_str": "Error",
-                        "periodicity": rule.get("period_label", "Error"),
-                        "ok": False
-                    }
+        for gf in general_freqs:
+            if isinstance(gf, dict):
+                freq_rules.append({
+                    "code": str(gf.get("code", "")).strip(),
+                    "qty": int(gf.get("qty", 1)),
+                    "type": str(gf.get("type", "Mes")),
+                    "period_label": str(gf.get("period_label", "Mensual"))
+                })
+
+        # B) Reglas desde Legacy (Objetivos sin anios_codigo)
+        if not general_freqs and m.get("frecuencia") and not m.get("active_year_codes"):
+            frec_legacy = str(m.get("frecuencia", "")).lower()
+            if "semestral" in frec_legacy:
+                ptype, plabel, pqty = "Mes", "Semestral", 6
+            elif "anual" in frec_legacy:
+                 ptype, plabel, pqty = "Mes", "Anual", 12
+            else:
+                 ptype, plabel, pqty = "Mes", "Mensual", 1
             
-            # 3. Inyectar resultados en 'res'
-            # keys: FREQ_RES_{code}, FREQ_PER_{code}
-            for k, v in resultados_freq.items():
-                code_key = k.replace("FREQ_", "") # e.g. 301001
-                
-                # Mapear a columnas del Excel (Correcci├│n de Nombres)
-                # El Excel espera "Freq {code}" y "Period {code}"
-                label_freq = f"Freq {code_key}"
-                label_per = f"Period {code_key}"
-                
-                res[label_freq] = v["result_str"]
-                res[label_per] = v["periodicity"]
-                
-                # Legacy Column Support (Frecuencia)
-                if m.get("active_year_codes") and selected_year_code and selected_year_code.get("code") == code_key:
-                     res["Freq CodxA├▒o"] = v["result_str"]
-                     res["Period CodxA├▒o"] = v["periodicity"] # Nombre nuevo alineado
+            # Aplicar a todos los objetivos configurados
+            for o in objetivos_cfg:
+                freq_rules.append({
+                    "code": o,
+                    "qty": pqty,
+                    "type": ptype,
+                    "period_label": plabel
+                })
+
+        # C) Reglas desde anios_codigo (C├â┬│digo por A├â┬▒o) - SI EST├â┬ü ACTIVO
+        if m.get("active_year_codes") and selected_year_code:
+            # Solo aplicamos regla para el c├â┬│digo seleccionado autom├â┬íticamente
+            # (El resto de c├â┬│digos del a├â┬▒o se ignoran para no ensuciar)
+            freq_rules.append({
+                "code": selected_year_code.get("code", ""),
+                "qty": int(selected_year_code.get("qty", 1)),
+                "type": selected_year_code.get("type", "Mes"),
+                "period_label": selected_year_code.get("period_label", "Mensual")
+            })
+
+        # 2. Ejecutar validaci├â┬│n
+        freq_res = {}
+        for rule in freq_rules:
+             code = rule.get("code")
+             if not code: continue
+             # Validar usando el m├â┬®todo est├â┬ítico
+             val_res = FrequencyValidator.validar(prestaciones, rule, fobj)
+             
+             freq_res[code] = {
+                 "status": val_res.get("result_str", "Error"),
+                 "periodicity": val_res.get("periodicity", "Mensual")
+             }
+
+        # 3. Volcar resultados al Excel
+        # A) Resultados individuales por c├â┬│digo
+        for code, v in freq_res.items():
+            res[f"Freq {code}"] = v["status"]
+            res[f"Period {code}"] = v["periodicity"]
+        
+        # B) Resultado Global (Legacy "Frecuencia" column) - Solo si no usamos code-year
+        # Si hay code-year, la col Frecuencia usually is blank or summary?
+        # El usuario quiere "Freq CodxA├â┬▒o" y "Period CodxA├â┬▒o".
+        if m.get("active_year_codes") and selected_year_code:
+            c = selected_year_code.get("code", "")
+            if c in freq_res:
+                v = freq_res[c]
+                res["Freq CodxA├â┬▒o"] = v["status"]     # Nombre nuevo alineado
+                res["Period CodxA├â┬▒o"] = v["periodicity"] # Nombre nuevo alineado
 
     except Exception as e_freq:
         log_warn(f"Error analizando frecuencias V2: {e_freq}")
         res["Frecuencia"] = "Error Freq"
     
-    # Periodicidad Legacy Fallback: Solo si no se sete├│ y CodeYear EST├ü ACTIVO
-    if m.get("active_year_codes") and "Period CodxA├▒o" not in res:
-        res["Period CodxA├▒o"] = m.get("periodicidad", "") or m.get("frecuencia", "").capitalize()
+    # Periodicidad Legacy Fallback: Solo si no se sete├â┬│ y CodeYear EST├â┬ü ACTIVO
+    if m.get("active_year_codes") and "Period CodxA├â┬▒o" not in res:
+        res["Period CodxA├â┬▒o"] = m.get("periodicidad", "") or m.get("frecuencia", "").capitalize()
 
     # ===== HABILITANTES =====
     habs_cfg = _parse_code_list(m.get("habilitantes", []))
@@ -1303,13 +1268,13 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
 
             hab_vigentes = [h for h in habs_found if en_vigencia(fobj, h[1], VENTANA_VIGENCIA_DIAS)] if fobj else habs_found
 
-            # Simplificado: si hay al menos uno vigente, est├í OK
+            # Simplificado: si hay al menos uno vigente, est├â┬í OK
             if hab_vigentes:
                 res["Hab Vi"] = "Vigente"
             else:
                 res["Hab Vi"] = "No Vigente"
         else:
-            # Sin habilitantes = vac├¡o (no texto)
+            # Sin habilitantes = vac├â┬¡o (no texto)
             res["Hab Vi"] = ""
 
     # ===== EXCLUYENTES =====
@@ -1332,42 +1297,42 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
             res["C Excluyente"] = join_clean([x[0] for x in excl_found])
             res["F Excluyente"] = join_clean([x[1] for x in excl_found])
 
-    # ===== OBSERVACI├ôN FOLIO =====
+    # ===== OBSERVACI├âÔÇ£N FOLIO =====
     if req_oa:
         obs_folio_list = []
         if folios_oa_encontrados:
             ahora = datetime.now()
             un_ano_atras = ahora - timedelta(days=365)
 
-            # Obtener referencias de prestaciones del ├║ltimo a├▒o
+            # Obtener referencias de prestaciones del ├â┬║ltimo a├â┬▒o
             refs_prestaciones = []
             for p in prestaciones:
                 p_dt = dparse(p.get("fecha", ""))
                 if p_dt and p_dt >= un_ano_atras:
                     refs_prestaciones.append(_norm(p.get("ref", "")))
 
-            # Normalizar c├│digos a buscar si el filtro est├í activo
+            # Normalizar c├â┬│digos a buscar si el filtro est├â┬í activo
             codigos_filtro = set()
             if OBSERVACION_FOLIO_FILTRADA and CODIGOS_FOLIO_BUSCAR:
                 codigos_filtro = {normalizar_codigo(c) for c in CODIGOS_FOLIO_BUSCAR if c}
 
             for folio, dt_oa, codigo, derivado, fecha_str in folios_oa_encontrados:
                 if dt_oa >= un_ano_atras:
-                    # Si hay filtro activo, verificar que el c├│digo est├® en la lista
+                    # Si hay filtro activo, verificar que el c├â┬│digo est├â┬® en la lista
                     if OBSERVACION_FOLIO_FILTRADA and codigos_filtro:
                         codigo_norm = normalizar_codigo(codigo)
                         if codigo_norm not in codigos_filtro:
                             continue
                     
-                    # Verificar que el folio est├® usado en prestaciones
+                    # Verificar que el folio est├â┬® usado en prestaciones
                     folio_clean = _norm(folio).replace("oa", "").strip()
                     if folio_clean and any(folio_clean in ref for ref in refs_prestaciones):
-                        obs_folio_list.append(f"Fol {folio} / C├│d {codigo} / Fec {fecha_str}")
+                        obs_folio_list.append(f"Fol {folio} / C├â┬│d {codigo} / Fec {fecha_str}")
 
-        res["Observaci├│n Folio"] = " | ".join(obs_folio_list)
+        res["Observaci├â┬│n Folio"] = " | ".join(obs_folio_list)
     
     # ===== FOLIO VIH =====
-    # Si la misi├│n tiene folio_vih activado, buscar c├│digos VIH en OA y verificar uso en PO
+    # Si la misi├â┬│n tiene folio_vih activado, buscar c├â┬│digos VIH en OA y verificar uso en PO
     if m.get("folio_vih", False):
         folio_vih_codigos = m.get("folio_vih_codigos", [])
         if folio_vih_codigos:
@@ -1375,36 +1340,36 @@ def analizar_mision(sigges, m: Dict[str, Any], casos_data: List[Dict[str, Any]],
                 vih_text = buscar_folio_vih(sigges, root, folio_vih_codigos)
                 res["Folio VIH"] = vih_text
                 if vih_text:
-                    log_info(f"­ƒº¼ Folio VIH encontrado: {vih_text}")
+                    log_info(f"├░┼©┬º┬¼ Folio VIH encontrado: {vih_text}")
             except Exception as e:
-                log_error(f"ÔØî Error en Folio VIH: {e}")
+                log_error(f"├ó┬Ø┼Æ Error en Folio VIH: {e}")
                 res["Folio VIH"] = ""
         else:
             res["Folio VIH"] = ""
     else:
-        # Solo agregar columna si est├í activado
+        # Solo agregar columna si est├â┬í activado
         if "Folio VIH" in res:
             res["Folio VIH"] = ""
 
-    # ===== OBSERVACI├ôN GENERAL =====
-    # Solo fallecimiento, como pidi├│ el usuario.
+    # ===== OBSERVACI├âÔÇ£N GENERAL =====
+    # Solo fallecimiento, como pidi├â┬│ el usuario.
     obs_parts = []
     if fall_dt:
         obs_parts.append(f"PACIENTE FALLECIDO EL {fall_dt.strftime('%d/%m/%Y')}")
     
     if obs_parts:
-        # Si ya hab├¡a algo (ej de OA/SIC), lo preservamos o sobreescribimos?
-        # El usuario dijo "La columna Observacion por ahora la quiero vac├¡a... solo si fallecio".
-        # PERO en conexiones ya pusimos observaciones si hab├¡a tracking.
-        # En la l├│gica nueva ┬┐Apto? es la clave. Observaci├│n queda para cosas graves.
+        # Si ya hab├â┬¡a algo (ej de OA/SIC), lo preservamos o sobreescribimos?
+        # El usuario dijo "La columna Observacion por ahora la quiero vac├â┬¡a... solo si fallecio".
+        # PERO en conexiones ya pusimos observaciones si hab├â┬¡a tracking.
+        # En la l├â┬│gica nueva ├é┬┐Apto? es la clave. Observaci├â┬│n queda para cosas graves.
         # Verificamos si ya tiene algo (ej "Sin Caso" de arriba)
         
-        current = res.get("Observaci├│n", "")
+        current = res.get("Observaci├â┬│n", "")
         if current and current != "Sin Caso":
-             res["Observaci├│n"] = current + " | " + " | ".join(obs_parts)
+             res["Observaci├â┬│n"] = current + " | " + " | ".join(obs_parts)
         else:
-             res["Observaci├│n"] = " | ".join(obs_parts)
-    # Si no falleci├│ y no hubo errores previos, Observaci├│n queda vac├¡a (o "Sin Caso" si fall├│ al inicio)
+             res["Observaci├â┬│n"] = " | ".join(obs_parts)
+    # Si no falleci├â┬│ y no hubo errores previos, Observaci├â┬│n queda vac├â┬¡a (o "Sin Caso" si fall├â┬│ al inicio)
 
     return res
 
@@ -1421,15 +1386,15 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
     - Valida RUT antes de buscar
     - Valida fecha antes de procesar
     - Verifica estado del navegador
-    - Detecta mantenimiento de p├ígina
+    - Detecta mantenimiento de p├â┬ígina
     
     RECOVERY INTELIGENTE:
     - Reintentos con backoff exponencial
-    - Skip autom├ítico tras MAX_REINTENTOS
-    - Continuaci├│n con siguiente paciente
+    - Skip autom├â┬ítico tras MAX_REINTENTOS
+    - Continuaci├â┬│n con siguiente paciente
     
     Returns:
-        Tupla (lista de resultados por misi├│n, ├®xito bool)
+        Tupla (lista de resultados por misi├â┬│n, ├â┬®xito bool)
     """
     # Validar columnas
     max_idx = max(INDICE_COLUMNA_RUT, INDICE_COLUMNA_FECHA, INDICE_COLUMNA_NOMBRE or 0)
@@ -1450,76 +1415,75 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
         req_ipd = any(bool(m.get("require_ipd", REVISAR_IPD)) for m in MISSIONS) if MISSIONS else REVISAR_IPD
         req_oa = any(bool(m.get("require_oa", REVISAR_OA)) for m in MISSIONS) if MISSIONS else REVISAR_OA
         req_aps = any(bool(m.get("require_aps", REVISAR_APS)) for m in MISSIONS) if MISSIONS else REVISAR_APS
-        req_aps = any(bool(m.get("require_aps", REVISAR_APS)) for m in MISSIONS) if MISSIONS else REVISAR_APS
         req_sic = any(bool(m.get("require_sic", REVISAR_SIC)) for m in MISSIONS) if MISSIONS else REVISAR_SIC
         
-        # FIX: Inicializar variable para evitar NameError si falla el c├ílculo
+        # FIX: Inicializar variable para evitar NameError si falla el c├â┬ílculo
         selected_year_code = None
 
         while intento < MAX_REINTENTOS_POR_PACIENTE and not resuelto:
             intento += 1
 
             try:
-                # Verificar conexi├│n ANTES de cada intento
+                # Verificar conexi├â┬│n ANTES de cada intento
                 if intento > 1:
                     is_valid, error_msg = sigges.validar_conexion()
                     if not is_valid:
                         raise FatalConnectionError(error_msg)
                 
-                # ­ƒöä ESTRATEGIA DE REINTENTOS PROGRESIVA (6 intentos con tiempos incrementales)
+                # ├░┼©ÔÇØÔÇ× ESTRATEGIA DE REINTENTOS PROGRESIVA (6 intentos con tiempos incrementales)
                 if intento == 1:
                     # Reintento 1: Optimizado (Sin espera artificial)
-                    # log_warn(f"­ƒöä Intento 1... (R├ípido)") 
-                    # time.sleep(0.5) # Peque├▒a pausa t├®cnica solamente
+                    # log_warn(f"├░┼©ÔÇØÔÇ× Intento 1... (R├â┬ípido)") 
+                    # time.sleep(0.5) # Peque├â┬▒a pausa t├â┬®cnica solamente
                     sigges.asegurar_submenu_ingreso_consulta_abierto(force=True)
                     sigges.ir(XPATHS["BUSQUEDA_URL"])
                     
                 elif intento == 2:
                     # Reintento 2: Normal, espera 10 segundos
-                    log_warn(f"­ƒöä Reintento 2/{MAX_REINTENTOS_POR_PACIENTE} para {rut} - Espera extendida")
+                    log_warn(f"├░┼©ÔÇØÔÇ× Reintento 2/{MAX_REINTENTOS_POR_PACIENTE} para {rut} - Espera extendida")
                     time.sleep(10)  # Espera 10 segundos
                     sigges.asegurar_submenu_ingreso_consulta_abierto(force=True)
                     sigges.ir(XPATHS["BUSQUEDA_URL"])
                     
                 elif intento == 3:
                     # Reintento 3: REFRESH + espera 10 segundos
-                    log_warn(f"­ƒöä Reintento 3/{MAX_REINTENTOS_POR_PACIENTE} para {rut} - REFRESH DE P├üGINA")
+                    log_warn(f"├░┼©ÔÇØÔÇ× Reintento 3/{MAX_REINTENTOS_POR_PACIENTE} para {rut} - REFRESH DE P├â┬üGINA")
                     try:
                         sigges.driver.refresh()
-                        log_info("Ô£à Refresh ejecutado en reintento 3")
+                        log_info("├ó┼ôÔÇª Refresh ejecutado en reintento 3")
                     except Exception as e:
-                        log_error(f"ÔØî Error en refresh reintento 3: {e}")
+                        log_error(f"├ó┬Ø┼Æ Error en refresh reintento 3: {e}")
                     time.sleep(10)  # Espera 10 segundos para que cargue completamente
                     sigges.asegurar_submenu_ingreso_consulta_abierto(force=True)
                     sigges.ir(XPATHS["BUSQUEDA_URL"])
                     
                 elif intento == 4:
                     # Reintento 4: Normal, espera 10 segundos
-                    log_warn(f"­ƒöä Reintento 4/{MAX_REINTENTOS_POR_PACIENTE} para {rut}")
+                    log_warn(f"├░┼©ÔÇØÔÇ× Reintento 4/{MAX_REINTENTOS_POR_PACIENTE} para {rut}")
                     time.sleep(10)  # Espera 10 segundos
                     sigges.asegurar_submenu_ingreso_consulta_abierto(force=True)
                     sigges.ir(XPATHS["BUSQUEDA_URL"])
                     
                 elif intento == 5:
                     # Reintento 5: Normal, espera 10 segundos
-                    log_warn(f"­ƒöä Reintento 5/{MAX_REINTENTOS_POR_PACIENTE} para {rut}")
+                    log_warn(f"├░┼©ÔÇØÔÇ× Reintento 5/{MAX_REINTENTOS_POR_PACIENTE} para {rut}")
                     time.sleep(10)  # Espera 10 segundos
                     sigges.asegurar_submenu_ingreso_consulta_abierto(force=True)
                     sigges.ir(XPATHS["BUSQUEDA_URL"])
                     
                 elif intento == 6:
                     # Reintento 6: REFRESH FINAL + espera 30 segundos
-                    log_warn(f"­ƒöä Reintento 6/{MAX_REINTENTOS_POR_PACIENTE} para {rut} - REFRESH FINAL CON ESPERA EXTENDIDA")
+                    log_warn(f"├░┼©ÔÇØÔÇ× Reintento 6/{MAX_REINTENTOS_POR_PACIENTE} para {rut} - REFRESH FINAL CON ESPERA EXTENDIDA")
                     try:
                         sigges.driver.refresh()
-                        log_info("Ô£à Refresh final ejecutado en reintento 6")
+                        log_info("├ó┼ôÔÇª Refresh final ejecutado en reintento 6")
                     except Exception as e:
-                        log_error(f"ÔØî Error en refresh reintento 6: {e}")
-                    time.sleep(30)  # Espera 30 segundos (m├íximo) para estabilizar
+                        log_error(f"├ó┬Ø┼Æ Error en refresh reintento 6: {e}")
+                    time.sleep(30)  # Espera 30 segundos (m├â┬íximo) para estabilizar
                     sigges.asegurar_submenu_ingreso_consulta_abierto(force=True)
                     sigges.ir(XPATHS["BUSQUEDA_URL"])
 
-                # ­ƒºá NUEVO TIMING SYSTEM: Robusto y autom├ítico
+                # ├░┼©┬º┬á NUEVO TIMING SYSTEM: Robusto y autom├â┬ítico
                 from Z_Utilidades.Principales.Timing2 import TimingContext
                 
                 # Reset timer global para este paciente
@@ -1544,12 +1508,12 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
                     el.clear()
                     el.send_keys(rut)
                     if not sigges.click_buscar():
-                        log_warn("Bot├│n buscar no encontrado, reintentando...")
-                        raise Exception("Bot├│n buscar no encontrado")
+                        log_warn("Bot├â┬│n buscar no encontrado, reintentando...")
+                        raise Exception("Bot├â┬│n buscar no encontrado")
                 
                 # Paso 4: Esperar spinner (OPTIMIZADO: 0.5s en vez de 1s)
-                # RAZ├ôN: Spinner aparece en <300ms normalmente
-                # SEGURO: Si tarda m├ís, WebDriverWait lo detecta igual
+                # RAZ├âÔÇ£N: Spinner aparece en <300ms normalmente
+                # SEGURO: Si tarda m├â┬ís, WebDriverWait lo detecta igual
                 with TimingContext("Paso 4 - Esperar spinner", rut):
                     sigges.esperar_spinner(appear_timeout=0.5, clave_espera="search_wait_results")
                 
@@ -1557,22 +1521,22 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
                 with TimingContext("Paso 5 - Leer mini-tabla", rut) as ctx:
                     mini = leer_mini_tabla(sigges)
                     if mini:
-                        ctx.extra_info = f"­ƒôè {len(mini)} caso(s)"
+                        ctx.extra_info = f"├░┼©ÔÇ£┼á {len(mini)} caso(s)"
                 
-                # Verificaci├│n r├ípida
+                # Verificaci├â┬│n r├â┬ípida
                 if not mini:
                     # NO verificar estado - es lento y innecesario
                     res_paci = [vac_row(m, fecha, rut, nombre, "Sin Caso mini") for m in MISSIONS]
                     resuelto = True
                     continue
                 
-                # Ô£à Hay casos - procesar r├ípidamente
-                log_info(f"{rut}: Ô£à {len(mini)} caso(s) encontrado(s)")
+                # ├ó┼ôÔÇª Hay casos - procesar r├â┬ípidamente
+                log_info(f"{rut}: ├ó┼ôÔÇª {len(mini)} caso(s) encontrado(s)")
                 
-                # Optimizar b├║squeda de keywords
+                # Optimizar b├â┬║squeda de keywords
                 from Z_Utilidades.Motor.Mini_Tabla import resolver_casos_duplicados
                 
-                # 5´©ÅÔâú.1 Resolver keywords
+                # 5├»┬©┬Å├óãÆ┬ú.1 Resolver keywords
                 with TimingContext("Paso 5.1 - Resolver keywords", rut):
                     caso_encontrado = None
                     razon = ""
@@ -1602,7 +1566,7 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
                 with TimingContext("Paso 6 - Leer edad", rut) as ctx:
                     edad = sigges.leer_edad()
                     if edad:
-                        ctx.extra_info = f"­ƒæñ {edad} a├▒os"
+                        ctx.extra_info = f"├░┼©ÔÇÿ┬ñ {edad} a├â┬▒os"
                 
                 # Paso 7: Navegar a cartola
                 with TimingContext("Paso 7 - Navegar a Cartola", rut):
@@ -1610,7 +1574,7 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
                         log_warn("No se pudo ir a cartola, reintentando...")
                         raise Exception("Fallo ir a cartola")
                 
-                # Imprimir resumen b├║squeda ÔåÆ cartola
+                # Imprimir resumen b├â┬║squeda ├óÔÇáÔÇÖ cartola
                 TimingContext.print_summary(rut)
  
                 # Activar hitos GES
@@ -1631,7 +1595,7 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
                     # Si encontramos datos, bien
                     if casos_data:
                         if intentos_lectura > 0:
-                             log_ok(f"Ô£à Datos cargaron tras reintento {intentos_lectura}")
+                             log_ok(f"├ó┼ôÔÇª Datos cargaron tras reintento {intentos_lectura}")
                         break
                         
                     # Si no encontramos datos, pero la mini-tabla dijo que SI -> Esperar
@@ -1639,14 +1603,14 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
                         intentos_lectura += 1
                         time.sleep(0.5)
                         if intentos_lectura % 2 == 0:
-                            log_warn(f"Ôîø Esperando carga de cartola... ({intentos_lectura}/{max_intentos_lectura})")
+                            log_warn(f"├ó┼ÆÔÇ║ Esperando carga de cartola... ({intentos_lectura}/{max_intentos_lectura})")
                     else:
-                        break # Si mini-tabla dijo NO, confiamos en la primera lectura vac├¡a
+                        break # Si mini-tabla dijo NO, confiamos en la primera lectura vac├â┬¡a
 
-                # Analizar cada misi├│n
+                # Analizar cada misi├â┬│n
                 res_paci = []
                 for m_idx, m in enumerate(ACTIVE_MISSIONS, 1):
-                    # Analizar misi├│n
+                    # Analizar misi├â┬│n
                     r = analizar_mision(
                         sigges, m, casos_data, fobj, fecha, fall_dt, edad, rut, nombre, 
                         caso_info=caso_encontrado  # Puede ser None o el caso encontrado
@@ -1656,61 +1620,61 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
                 resuelto = True
 
             except Exception as e:
-                # Verificar si el error es FATAL (navegador cerrado/conexi├│n perdida)
+                # Verificar si el error es FATAL (navegador cerrado/conexi├â┬│n perdida)
                 if sigges.es_conexion_fatal(e):
-                    log_error(f"­ƒÜ¿ {rut}: ERROR FATAL detectado - Navegador desconectado")
+                    log_error(f"├░┼©┼í┬¿ {rut}: ERROR FATAL detectado - Navegador desconectado")
                     log_error(str(e))
-                    log_error("Ôöü" * 60)
-                    log_error("ÔÜá´©Å  El navegador Edge se cerr├│ o perdi├│ la conexi├│n")
-                    log_error("ÔÜá´©Å  Por favor:")
+                    log_error("├óÔÇØ┬ü" * 60)
+                    log_error("├ó┼í┬á├»┬©┬Å  El navegador Edge se cerr├â┬│ o perdi├â┬│ la conexi├â┬│n")
+                    log_error("├ó┼í┬á├»┬©┬Å  Por favor:")
                     log_error("   1. Cierra todas las ventanas de Edge")
                     log_error("   2. Ejecuta init.ps1 para reiniciar Edge en modo debug")
                     log_error("   3. Vuelve a ejecutar el script")
-                    log_error("Ôöü" * 60)
-                    # Propagar para abortar ejecuci├│n completa
+                    log_error("├óÔÇØ┬ü" * 60)
+                    # Propagar para abortar ejecuci├â┬│n completa
                     raise FatalConnectionError(str(e))
                 
                 # Error transiente - mostrar y continuar con reintentos
                 log_error(f"{rut}: Error en intento {intento}: {pretty_error(e)}")
                 if intento >= MAX_REINTENTOS_POR_PACIENTE:
-                    log_warn(f"ÔØî {rut}: Saltado tras {intento} intentos")
+                    log_warn(f"├ó┬Ø┼Æ {rut}: Saltado tras {intento} intentos")
                 # Diagnosticar tipo de error para debugging
                 clasificar_error(e, silencioso=False)
 
         if not resuelto:
-            # ÔÜá´©Å Paciente saltado despu├®s de agotar todos los reintentos
-            log_warn(f"ÔÜá´©Å Paciente {rut} SALTADO tras {MAX_REINTENTOS_POR_PACIENTE} reintentos")
+            # ├ó┼í┬á├»┬©┬Å Paciente saltado despu├â┬®s de agotar todos los reintentos
+            log_warn(f"├ó┼í┬á├»┬©┬Å Paciente {rut} SALTADO tras {MAX_REINTENTOS_POR_PACIENTE} reintentos")
             
-            # ­ƒöä CR├ìTICO: Refresh completo para limpiar estado corrupto antes de siguiente paciente
+            # ├░┼©ÔÇØÔÇ× CR├â┬ìTICO: Refresh completo para limpiar estado corrupto antes de siguiente paciente
             try:
-                log_info("­ƒöä Ejecutando refresh POST-REINTENTOS para limpiar estado corrupto...")
+                log_info("├░┼©ÔÇØÔÇ× Ejecutando refresh POST-REINTENTOS para limpiar estado corrupto...")
                 sigges.driver.refresh()
                 time.sleep(10)  # Espera 10 segundos para recarga completa
                 
-                log_info("­ƒº¡ Navegando a pantalla de b├║squeda limpia...")
+                log_info("├░┼©┬º┬¡ Navegando a pantalla de b├â┬║squeda limpia...")
                 sigges.asegurar_submenu_ingreso_consulta_abierto(force=True)
                 sigges.ir(XPATHS["BUSQUEDA_URL"])
                 time.sleep(3)  # Espera adicional para estabilizar
                 
-                log_ok("Ô£à Estado limpiado exitosamente - listo para siguiente paciente")
+                log_ok("├ó┼ôÔÇª Estado limpiado exitosamente - listo para siguiente paciente")
                 
             except Exception as e:
-                log_error(f"ÔØî Error durante refresh post-reintentos: {pretty_error(e)}")
-                # Continuar de todas formas - no queremos detener toda la ejecuci├│n
+                log_error(f"├ó┬Ø┼Æ Error durante refresh post-reintentos: {pretty_error(e)}")
+                # Continuar de todas formas - no queremos detener toda la ejecuci├â┬│n
             
-            # ­ƒöº Raz├│n detallada de omisi├│n + datos b├ísicos poblados
-            skip_reason = f"Paciente Saltado Autom├íticamente ({MAX_REINTENTOS_POR_PACIENTE} intentos fallidos)"
+            # ├░┼©ÔÇØ┬º Raz├â┬│n detallada de omisi├â┬│n + datos b├â┬ísicos poblados
+            skip_reason = f"Paciente Saltado Autom├â┬íticamente ({MAX_REINTENTOS_POR_PACIENTE} intentos fallidos)"
             res_paci = []
             for m in ACTIVE_MISSIONS:
                 row = vac_row(m, fecha, rut, nombre, skip_reason)
-                # Asegurar que datos b├ísicos est├®n presentes
+                # Asegurar que datos b├â┬ísicos est├â┬®n presentes
                 row["RUT"] = rut
                 row["Nombre"] = nombre  
-                row["Fecha N├│mina"] = fecha
-                row["Observaci├│n"] = skip_reason
+                row["Fecha N├â┬│mina"] = fecha
+                row["Observaci├â┬│n"] = skip_reason
                 res_paci.append(row)
 
-        # ­ƒôè Timing: Resumen del paciente
+        # ├░┼©ÔÇ£┼á Timing: Resumen del paciente
         t_resumen_start = time.time()
         resumen_paciente(
             idx + 1, total, nombre, rut, fecha,
@@ -1720,7 +1684,7 @@ def procesar_paciente(sigges, row, idx, total, t_script_inicio: float) -> Tuple[
         t_resumen_end = time.time()
         dt_resumen = (t_resumen_end - t_resumen_start)*1000
         if dt_resumen > 100:
-            print(f"{Fore.LIGHTBLACK_EX}    [Resumen paciente] ÔåÆ {dt_resumen:.0f}ms{Style.RESET_ALL}")
+            print(f"{Fore.LIGHTBLACK_EX}    [Resumen paciente] ├óÔÇáÔÇÖ {dt_resumen:.0f}ms{Style.RESET_ALL}")
 
         # Anotar orden de columnas para el exportador (evita duplicados/desorden)
         _inject_cols_order(res_paci)
@@ -1743,11 +1707,11 @@ def _inject_cols_order(rows: List[Dict[str, Any]]) -> None:
         pass
 
 # =============================================================================
-#                      EJECUTAR REVISI├ôN COMPLETA
+#                      EJECUTAR REVISI├âÔÇ£N COMPLETA
 # =============================================================================
 
 def _set_globals_for_mission(m: Dict[str, Any]) -> None:
-    """Ajusta ├¡ndices y flags globales para la misi├│n actual (compatibilidad legacy)."""
+    """Ajusta ├â┬¡ndices y flags globales para la misi├â┬│n actual (compatibilidad legacy)."""
     global INDICE_COLUMNA_FECHA, INDICE_COLUMNA_RUT, INDICE_COLUMNA_NOMBRE
     global REVISAR_IPD, REVISAR_OA, REVISAR_APS, REVISAR_SIC
     global FILAS_IPD, FILAS_OA, FILAS_APS, FILAS_SIC
@@ -1768,7 +1732,7 @@ def _set_globals_for_mission(m: Dict[str, Any]) -> None:
     FILAS_APS = int(m.get("max_aps", FILAS_APS))
     FILAS_SIC = int(m.get("max_sic", FILAS_SIC))
 
-    # --- NUEVO: Inyecci├│n completa de contexto ---
+    # --- NUEVO: Inyecci├â┬│n completa de contexto ---
     global NOMBRE_DE_LA_MISION, RUTA_ARCHIVO_ENTRADA, RUTA_CARPETA_SALIDA
     global FOLIO_VIH, FOLIO_VIH_CODIGOS, REVISAR_HABILITANTES, REVISAR_EXCLUYENTES
     
@@ -1785,13 +1749,13 @@ def _set_globals_for_mission(m: Dict[str, Any]) -> None:
 def ejecutar_revision() -> bool:
     """
     Ejecuta todas las misiones configuradas, una tras otra (cola).
-    Cada misi├│n usa su propio archivo de entrada/salida.
+    Cada misi├â┬│n usa su propio archivo de entrada/salida.
     """
     global ACTIVE_MISSIONS
     tiempo_inicio_global = datetime.now()
 
     if not MISSIONS:
-        log_error("ÔØî No hay misiones configuradas en Mision_Actual.py / mission_config.json")
+        log_error("├ó┬Ø┼Æ No hay misiones configuradas en Mision_Actual.py / mission_config.json")
         return False
 
     print("DEBUG: Entrando a ejecutar_revision")
@@ -1800,16 +1764,16 @@ def ejecutar_revision() -> bool:
         print(f"DEBUG: Intentando conectar a Edge en {DIRECCION_DEBUG_EDGE}")
         sigges = iniciar_driver(DIRECCION_DEBUG_EDGE, EDGE_DRIVER_PATH)
     except Exception as e:
-        log_error(f"ÔØî Error FATAL al iniciar driver: {e}")
+        log_error(f"├ó┬Ø┼Æ Error FATAL al iniciar driver: {e}")
         import traceback
         log_error(traceback.format_exc())
         return False
 
     try:
         for m_idx, m in enumerate(MISSIONS, 1):
-            # Preparar entorno para la misi├│n actual
+            # Preparar entorno para la misi├â┬│n actual
             ACTIVE_MISSIONS = [m]
-            # Compatibilidad: reducir MISSIONS a la misi├│n activa para cualquier referencia legacy
+            # Compatibilidad: reducir MISSIONS a la misi├â┬│n activa para cualquier referencia legacy
             globals()["MISSIONS"] = [m]
             _set_globals_for_mission(m)
 
@@ -1819,10 +1783,10 @@ def ejecutar_revision() -> bool:
             print(f"DEBUG: Procesando mision {nombre_m}, ruta_entrada={ruta_in}")
 
             if not os.path.exists(ruta_in):
-                log_error(f"Archivo no existe para la misi├│n {nombre_m}: {ruta_in}")
+                log_error(f"Archivo no existe para la misi├â┬│n {nombre_m}: {ruta_in}")
                 continue
 
-            # Cargar Excel de la misi├│n
+            # Cargar Excel de la misi├â┬│n
             try:
                 df = pd.read_excel(ruta_in)
                 log_ok(f"Excel cargado: {len(df)} filas")
@@ -1840,7 +1804,7 @@ def ejecutar_revision() -> bool:
 
             t_script_inicio = time.time()
             if should_show_timing():
-                print(f"{Fore.YELLOW}ÔÅ▒´©Å Timer global iniciado - timing acumulativo continuo{Style.RESET_ALL}\n")
+                print(f"{Fore.YELLOW}├ó┬Å┬▒├»┬©┬Å Timer global iniciado - timing acumulativo continuo{Style.RESET_ALL}\n")
 
             for idx, row in df.iterrows():
                 if idx > 0 and idx % 50 == 0:
@@ -1848,7 +1812,7 @@ def ejecutar_revision() -> bool:
                 try:
                     filas, ok = procesar_paciente(sigges, row, idx, total, t_script_inicio)
                 except FatalConnectionError:
-                    log_warn("Ôøö Sesi├│n perdida. Reintentando reiniciar Edge y continuar con el mismo paciente...")
+                    log_warn("├óÔÇ║ÔÇØ Sesi├â┬│n perdida. Reintentando reiniciar Edge y continuar con el mismo paciente...")
                     # Intentar reiniciar driver una sola vez
                     try:
                         sigges.driver.quit()
@@ -1858,12 +1822,12 @@ def ejecutar_revision() -> bool:
                         sigges = iniciar_driver(DIRECCION_DEBUG_EDGE, EDGE_DRIVER_PATH)
                         filas, ok = procesar_paciente(sigges, row, idx, total, t_script_inicio)
                     except Exception as e2:
-                        log_error(f"ÔØî No se pudo recuperar sesi├│n: {pretty_error(e2)}")
+                        log_error(f"├ó┬Ø┼Æ No se pudo recuperar sesi├â┬│n: {pretty_error(e2)}")
                         return False
 
                 if ok:
                     stats["exitosos"] += 1
-                elif filas and "saltado" in str(filas[0].get("Observaci├│n", "")).lower():
+                elif filas and "saltado" in str(filas[0].get("Observaci├â┬│n", "")).lower():
                     stats["saltados"] += 1
                 else:
                     stats["fallidos"] += 1
@@ -1872,7 +1836,7 @@ def ejecutar_revision() -> bool:
                     if i in resultados_por_mision:
                         resultados_por_mision[i].append(fila)
 
-                # Snapshot bajo demanda (bot├│n "Guardar Ahora")
+                # Snapshot bajo demanda (bot├â┬│n "Guardar Ahora")
                 control = get_execution_control()
                 if control.should_snapshot():
                     control.clear_snapshot_request()
@@ -1889,7 +1853,7 @@ def ejecutar_revision() -> bool:
                     except Exception as e:
                         log_warn(f"No se pudo guardar snapshot: {pretty_error(e)}")
 
-            # Generar Excel para esta misi├│n
+            # Generar Excel para esta misi├â┬│n
             archivo_salida = generar_excel_revision(
                 resultados_por_mision, [m],
                 nombre_m, ruta_out
@@ -1900,18 +1864,18 @@ def ejecutar_revision() -> bool:
                 tiempo_inicio_global, archivo_salida or "Error"
             )
             
-            # ­ƒöö NOTIFICACI├ôN DE SISTEMA ­ƒöö
+            # ├░┼©ÔÇØÔÇØ NOTIFICACI├âÔÇ£N DE SISTEMA ├░┼©ÔÇØÔÇØ
             try:
-                msg_notif = f"Ô£à Revisi├│n completada con ├®xito.\n­ƒôè Exitosos: {stats['exitosos']} | Fallidos: {stats['fallidos']}"
+                msg_notif = f"├ó┼ôÔÇª Revisi├â┬│n completada con ├â┬®xito.\n├░┼©ÔÇ£┼á Exitosos: {stats['exitosos']} | Fallidos: {stats['fallidos']}"
                 if stats['fallidos'] > 0:
-                     msg_notif = f"ÔÜá´©Å Revisi├│n finalizada con observaciones.\nÔØî Fallidos: {stats['fallidos']} | Exitosos: {stats['exitosos']}"
+                     msg_notif = f"├ó┼í┬á├»┬©┬Å Revisi├â┬│n finalizada con observaciones.\n├ó┬Ø┼Æ Fallidos: {stats['fallidos']} | Exitosos: {stats['exitosos']}"
                 
                 get_notifications().send_system_notification(
                     title=f"Nozhgess: {nombre_m}",
                     message=msg_notif
                 )
             except Exception as e:
-                log_warn(f"No se pudo enviar notificaci├│n: {e}")
+                log_warn(f"No se pudo enviar notificaci├â┬│n: {e}")
 
         return True
 
@@ -1925,7 +1889,7 @@ def ejecutar_revision() -> bool:
 
 
 # =============================================================================
-#                         EJECUCI├ôN DIRECTA
+#                         EJECUCI├âÔÇ£N DIRECTA
 # =============================================================================
 
 if __name__ == "__main__":
